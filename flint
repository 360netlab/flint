#!/usr/bin/python
import sys
import socket
import urllib2
import hashlib
import optparse
import time
from StringIO import StringIO
from datetime import datetime
try:
    import json
except ImportError:
    import simplejson as json
import traceback

__VERSION__ = "0.1.6"

__AUTHOR__ = "netlab@360.cn"

"""
How to using this script?

First. 
    Email passivedns@360.cn to apply the API_ID & API_KEY
Second. 
    Assign the API_ID and API_KEY we allocated for you 
"""

API = "node002v.add.lyct.qihoo.net"

#This ID will be used as the identification by authentication system 
API_ID = "domestic_inner_flint_keqiang"

#This key is matched with API_ID, be used for calcuate message hash token.
API_KEY = "gSA2Jk$FyorlrhYvhDE9WP./5kam.i"


FLINT_TABLES = ['rrset', 'rdata']

FLINT_SORT_FIELD = ["time_last", "time_first", "count"]

FLINT_TYPES = {
        "A" : 1,
        "NS" : 2,
        "MD" : 3,
        "CNAME" : 5,
        "SOA" : 6,
        "PTR" : 12,
        "MX" : 15,
        "TXT" : 16,
        "AAAA" : 28,
        "SRV" : 33,
        "DNAME" : 39,
        "DS" : 43,
        "RRSIG" : 46,
        "NSEC" : 47,
        "NSEC3" : 50
}


class FlintClient(object):

    TIMEOUT = 30

    def __init__(self, api, api_id, api_key, verbose = False):
        self.api = API
        self.api_id = API_ID
        self.api_key = API_KEY
        self.verbose = verbose

    def __call__(self, f_table, f_keyword, f_type, *args, **kwargs):
        getattr(self, f_table)(f_keyword, f_type, *args, **kwargs)


    def _do_query(self, req):
        def _safe_in_query(req):
            try:
                url  = req.get_full_url()
                http = urllib2.urlopen(req, timeout=self.TIMEOUT)
                resp = http.read()
                if self.verbose:
                    print "################"
                    print "#### REQUEST ###"
                    print "################"
                    print url 
                    print req.headers
                    print 
                    print "#################"
                    print "#### RESPONSE ###"
                    print "#################"
                    print http.code
                    print http.headers
                    print resp[:100], "..." if len(resp) > 100 else resp
                    print "============================================"
                    print 
                try:
                    resp = json.loads(resp)
                except Exception, e:
                    self.panic(resp)

                if isinstance(resp, dict) and 'err' in resp:
                    msg = resp.get("msg", "") or resp.get("err", "")
                    self.panic(">>> Server Exception: %s" % msg, False)
                    return None

                return resp
            except socket.timeout:
                self.panic("[api timeout]: %s" %(url))
                return None
            except (urllib2.HTTPError, urllib2.URLError),e:
                self.panic("[api error]: %s" %(url))
                return None
        while 1:
            ret = _safe_in_query(req)
            if ret is not None:
                return ret
            time.sleep(1)
            continue


    def next_query(self, path):
        url = "http://%s%s" %(self.api, path)
        req = urllib2.Request(url)
        req.add_header('Accept', 'application/json')
        if self.api_id:
            req.add_header('X-BashTokid', self.api_id);
        if self.api_key:
            token = self.genToken(path, self.api_key)
            req.add_header('X-BashToken', token)

        return self._do_query(req)


    def query(self, f_table, f_keyword, f_type = None, f_netmask = None, limit = 100000000):
        path = "/api/%s/keyword/%s/count/%s/" %(f_table, f_keyword, limit)
        if f_type is not None:
            path = "%srtype/%s/" %(path, FLINT_TYPES[f_type])
        if f_netmask is not None:
            path = "%smask/%s/" %(path, str(f_netmask))
        if self.api.startswith("http://"):
            url = "%s%s" %(self.api, path)
        else:
            url = "http://%s%s" %(self.api, path)

        req = urllib2.Request(url)
        req.add_header('Accept', 'application/json')
        if self.api_id:
            req.add_header('X-BashTokid', self.api_id);
        if self.api_key:
            token = self.genToken(path, self.api_key)
            req.add_header('X-BashToken', token)

        return self._do_query(req)


    def filter(self, resp, sort, reverse, before, after):
        resp = sorted(resp, key=lambda x:x[sort], reverse=reverse)
        if before:
            try:
                before = self.time_parse(before)
                resp = filter(lambda x:x['time_first'] < before, resp)
            except ValueError, e:
                self.panic("filter error with before: %s", before)
        if after:
            try:
                after = self.time_parse(after)
                resp = filter(lambda x:x['time_last'] > after, resp)
            except ValueError,e:
                self.panic("filter error with after: %s", after)
        return resp


    def rrset(self, rrname, rrtype=None, sort="time_last", reverse=False,
                limit=100000000, jsond=False, after=None, before=None, **kwargs):

        def _dump(rrname, rrtype, resp):
            s = StringIO()
            s.write("%s %s In rrset\n" %(rrname, rrtype or "All Type"))
            s.write("-------\n")
            for r in resp:
                s.write("Record times: %s -- %s\n" %(self._timefmt(r['time_first']), 
                    self._timefmt(r['time_last'])))
                s.write("Count: %d\n" %(int(r['count'])))
                rdata = r['rdata'].rstrip(";").split(";")
                for data in rdata:
                    s.write("%s\t%s\t%s\n" %(r['rrname'], r['rrtype'], data))
                s.write("\n")
            s.seek(0)
            return s.read()

        resp = self.query("rrset", rrname, rrtype, limit=limit)
        while 1:
            next = None
            if isinstance(resp, dict):
                next = resp.get("next_call", None)
                resp = resp.get("data", [])
            if self.verbose:
                print ">>> Get Next: ", next
            if resp:
                resp = self.filter(resp, sort, reverse, before, after)
                if jsond:
                    print json.dumps(resp)
                else:
                    print _dump(rrname, rrtype, resp)
            if not next:
                print ">>> All Done"
                break
            resp = self.next_query(next)


    def rdata(self, rdata, rrtype=None, limit=100000000, jsond=False, **kwargs):

        def _dump(rdata, rrtype, resp):
            s = StringIO()
            s.write("%s %s In rdata\n" %(rdata, rrtype or "All Type"))
            s.write("--------\n")
            for r in resp:
                s.write("%s\t%s\t%s" %(r['rrname'], r['rrtype'], r['rdata']))
                s.write("\n")
            s.seek(0)
            return s.read()

        if self.is_cidr(rdata):
            ip, netmask = rdata.split("/")    
            resp = self.query("rdata", ip, rrtype, netmask, limit=limit)
        else:
            resp = self.query("rdata", rdata, rrtype, limit=limit)

        while 1:
            next = None
            if isinstance(resp, dict):
                next = resp.get("next_call", None)
                resp = resp.get("data", [])
            if self.verbose:
                print ">>> Get Next: ", next
            if resp:
                if jsond:
                    print json.dumps(resp)
                else:
                    print _dump(rdata, rrtype, resp)
            if not next:
                print ">>> All Done"
                break
            resp = self.next_query(next)


    def panic(self, error, hard=True):
        sys.stderr.write("%s\n" %error)
        if hard: 
            sys.exit(1)

    def _timefmt(self, ts):
        try:
            return datetime.fromtimestamp(ts)
        except:
            return ""

    #This function is copy from dnsdb-query
    def time_parse(self, s):
        try:
            epoch = int(s)
            return epoch
        except ValueError:
            pass

        try:
            epoch = int(time.mktime(time.strptime(s, '%Y-%m-%d')))
            return epoch
        except ValueError:
            pass

        try:
            epoch = int(time.mktime(time.strptime(s, '%Y-%m-%d %H:%M:%S')))
            return epoch
        except ValueError:
            pass

        raise ValueError('Invalid time: "%s"' % s)


    def is_cidr(self, cidr):
        try:
            ip, netmask = cidr.split("/")
        except:
            return False
        if not self.is_ip(ip):
            return False
        if int(netmask) < 24 or int(netmask) > 31:
            self.panic("Sorry. CIDR should between 24-31")
        return True
    
    def is_ip(self, ip):
        try:
            socket.inet_aton(ip)
            return True
        except socket.error:
            return False

    def genToken(self, path, key):
        str = "%s%s" %(path, key)
        return self.md5(str)

    def md5(self, str):
        m = hashlib.md5()
        m.update(str)
        return m.hexdigest()
    
        

def usage():
    s = StringIO()
    s.write("Usage: %s [<rrset>|<rdata>] [<domain>|<ip>] [type] [options]\n" %sys.argv[0])
    s.write("\t./flint rrset www.360.cn\n")
    s.write("\t./flint rdata 101.4.60.193 A\n")
    s.write("\t./flint rrset 360.cn -l 100\n")
    s.write("\t./flint rrset 360.cn --sort='time_first'\n")
    s.seek(0)
    return s.read()


def parse_option():
    parser = optparse.OptionParser(usage=usage())
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False)
    parser.add_option("-V", "--version", action="store_true", dest="version")
    parser.add_option("-j", "--json", action="store_true", dest="jsond", default=False,
                    help="output in json format")
    parser.add_option("-l", "--limit", action="store", type="int", default=100000000, dest="limit",
                    help="limit number of results. [default: %default]")
    parser.add_option("-s", "--sort", action="store", type="string", default="time_last", dest="sort",
                    help="|".join(FLINT_SORT_FIELD)+" [default: %default]")
    parser.add_option("-R", "--reverse", dest="reverse", action="store_false", default=True,
                    help="reverse sort")
    parser.add_option("", "--before", dest="before", type="string", action="store", 
                    help="only output results seen before this time")
    parser.add_option("", "--after", dest="after", type="string", action="store", 
                    help="only output results seen after this time")
    return parser

if __name__ == "__main__":

    parser = parse_option()
    options, args = parser.parse_args()

    if options.version:
        print "flint %s" %__VERSION__
        sys.exit(0)

    if len(args) <2:
        parser.print_help()
        sys.exit(1)

    f_table = args[0]
    if f_table not in FLINT_TABLES:
       sys.stderr.write("Table must be in %s\n" %("|".join(FLINT_TABLES)))
       sys.exit(1)

    f_keyword = args[1]
    
    f_type = args[2] if len(args)>2 else None
    if f_type is not None:
       f_type = f_type.upper()
       if f_type not in FLINT_TYPES.keys():
           sys.stderr.write("Type must be in %s\n" %("|".join(FLINT_TYPES)))
           sys.exit(1)

    if options.sort not in FLINT_SORT_FIELD:
        sys.stderr.write("Sort field must be in %s\n" %("|".join(FLINT_SORT_FIELD)))
        sys.exit(1)
        
    try:
        flint = FlintClient(API, API_ID, API_KEY, options.verbose) 
        flint(f_table, f_keyword, f_type, **options.__dict__)
    except KeyboardInterrupt, e:
        print ">>> User Interrupt."
    except Exception, e:
        sys.stderr.write("Client Exception")
        sys.stderr.write(traceback.format_exc())


    
    

