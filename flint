#!/usr/bin/python
import sys
import socket
import urllib2
import hashlib
import optparse
import time
from StringIO import StringIO
from datetime import datetime
try:
    import json
except ImportError:
    import simplejson as json

__VERSION__ = "0.1.3"

__AUTHOR__ = "netlab@360.cn"

"""
How to using this script?

First. 
    Email passivedns@360.cn to apply the API_ID & API_KEY
Second. 
    Assign the API_ID and API_KEY we allocated for you 
"""

API = "netlab.360.cn"

#This ID will be used as the identification by authentication system 
API_ID = ""

#This key is matched with API_ID, be used for calcuate message hash token.
API_KEY = ""


FLINT_TABLES = ['rrset', 'rdata']

FLINT_SORT_FIELD = ["time_last", "time_first", "count"]

FLINT_TYPES = {
        "A" : 1,
        "NS" : 2,
        "MD" : 3,
        "CNAME" : 5,
        "SOA" : 6,
        "PTR" : 12,
        "MX" : 15,
        "TXT" : 16,
        "AAAA" : 28,
        "SRV" : 33,
        "DNAME" : 39,
        "DS" : 43,
        "RRSIG" : 46,
        "NSEC" : 47,
        "NSEC3" : 50
}


class FlintClient(object):

    TIMEOUT = 30

    def __init__(self, api, api_id, api_key, verbose = False):
        self.api = API
        self.api_id = API_ID
        self.api_key = API_KEY
        self.verbose = verbose

    def __call__(self, f_table, f_keyword, f_type, *args, **kwargs):
        getattr(self, f_table)(f_keyword, f_type, *args, **kwargs)

    def query(self, f_table, f_keyword, f_type = None, f_netmask = None, limit = 1000):
        path = "/api/%s/keyword/%s/count/%s/" %(f_table, f_keyword, limit)
        if f_type is not None:
            path = "%srtype/%s/" %(path, FLINT_TYPES[f_type])
        if f_netmask is not None:
            path = "%smask/%s/" %(path, str(f_netmask))
        if self.api.startswith("http://"):
            url = "%s%s" %(self.api, path)
        else:
            url = "http://%s%s" %(self.api, path)

        req = urllib2.Request(url)
        req.add_header('Accept', 'application/json')
        if self.api_id:
            req.add_header('X-BashTokid', self.api_id);
        if self.api_key:
            token = self.genToken(path, self.api_key)
            req.add_header('X-BashToken', token)

        try:
            http = urllib2.urlopen(req, timeout=self.TIMEOUT)
            resp = http.read()
        except socket.timeout:
            print "[api timeout]: %s" %(url)
            sys.exit(1)
        except (urllib2.HTTPError, urllib2.URLError),e:
            print "[api error]: %s" %(url)
            sys.exit(1)

        if self.verbose:
            print "Request: "
            print url
            print req.headers
            print "\n"
            print "Response:"
            print http.code
            print http.headers

        try:
            resp = json.loads(resp)
        except:
            print resp
            sys.exit(1)
        return resp

    def filter(self, resp, sort, reverse, before, after):
        resp = sorted(resp, key=lambda x:x[sort], reverse=reverse)
        if before:
            try:
                before = self.time_parse(before)
                resp = filter(lambda x:x['time_first'] < before, resp)
            except ValueError, e:
                print e
        if after:
            try:
                after = self.time_parse(after)
                resp = filter(lambda x:x['time_last'] > after, resp)
            except ValueError,e:
                print e
        return resp


    def rrset(self, rrname, rrtype=None, sort="time_last", reverse=False,
                limit=1000, jsond=False, after=None, before=None, **kwargs):

        def _dump(rrname, rrtype, resp):
            s = StringIO()
            s.write("%s %s In rrset\n" %(rrname, rrtype or "All Type"))
            s.write("-------\n")
            for r in resp:
                s.write("Record times: %s -- %s\n" %(self._timefmt(r['time_first']), 
                    self._timefmt(r['time_last'])))
                s.write("Count: %d\n" %(int(r['count'])))
                rdata = r['rdata'].rstrip(";").split(";")
                for data in rdata:
                    s.write("%s\t%s\t%s\n" %(r['rrname'], r['rrtype'], data))
                s.write("\n")
            s.seek(0)
            return s.read()
                

        resp = self.query("rrset", rrname, rrtype, limit=limit)
        if resp:
            resp = self.filter(resp, sort, reverse, before, after)
            if jsond:
                print json.dumps(resp)
                return json.dumps(resp)
            else:
                print _dump(rrname, rrtype, resp)
        else:
            print "Empty"
        

    def rdata(self, rdata, rrtype=None, limit=1000, jsond=False, **kwargs):

        def _dump(rdata, rrtype, resp):
            s = StringIO()
            s.write("%s %s In rdata\n" %(rdata, rrtype or "All Type"))
            s.write("--------\n")
            for r in resp:
                s.write("%s\t%s\t%s" %(r['rrname'], r['rrtype'], r['rdata']))
                s.write("\n")
            s.seek(0)
            return s.read()

        if self.is_cidr(rdata):
            ip, netmask = rdata.split("/")    
            resp = self.query("rdata", ip, rrtype, netmask, limit=limit)
        else:
            resp = self.query("rdata", rdata, rrtype, limit=limit)

        if resp:
            if jsond:
                print json.dumps(resp)
                return json.dumps(resp)
            else:
                print _dump(rdata, rrtype, resp)
        else:
            print "Empty"

    def _timefmt(self, ts):
        try:
            return datetime.fromtimestamp(ts)
        except:
            return ""

    #This function is copy from dnsdb-query
    def time_parse(self, s):
        try:
            epoch = int(s)
            return epoch
        except ValueError:
            pass

        try:
            epoch = int(time.mktime(time.strptime(s, '%Y-%m-%d')))
            return epoch
        except ValueError:
            pass

        try:
            epoch = int(time.mktime(time.strptime(s, '%Y-%m-%d %H:%M:%S')))
            return epoch
        except ValueError:
            pass

        raise ValueError('Invalid time: "%s"' % s)

    def is_cidr(self, cidr):
        try:
            ip, netmask = cidr.split("/")
        except:
            return False
        if not self.is_ip(ip):
            return False
        if int(netmask) < 24 or int(netmask) > 31:
            print "Sorry. CIDR should between 24-31"
            sys.exit(1)
        return True
    
    def is_ip(self, ip):
        try:
            socket.inet_aton(ip)
            return True
        except socket.error:
            return False

    def genToken(self, path, key):
        str = "%s%s" %(path, key)
        return self.md5(str)

    def md5(self, str):
        m = hashlib.md5()
        m.update(str)
        return m.hexdigest()
    
        

def usage():
    s = StringIO()
    s.write("Usage: %s [<rrset>|<flinyrdara>] [<domain>|<ip>] [type] [options]\n" %sys.argv[0])
    s.write("\t./flint rrset www.360.cn\n")
    s.write("\t./flint rdata 101.4.60.193 A\n")
    s.write("\t./flint rrset 360.cn -l 100\n")
    s.write("\t./flint rrset 360.cn --sort='time_first'\n")
    s.seek(0)
    return s.read()


def parse_option():
    parser = optparse.OptionParser(usage=usage())
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False)
    parser.add_option("-V", "--version", action="store_true", dest="version")
    parser.add_option("-j", "--json", action="store_true", dest="jsond", default=False,
                    help="output in json format")
    parser.add_option("-l", "--limit", action="store", type="int", default=1000, dest="limit",
                    help="limit number of results. [default: %default]")
    parser.add_option("-s", "--sort", action="store", type="string", default="time_last", dest="sort",
                    help="|".join(FLINT_SORT_FIELD)+" [default: %default]")
    parser.add_option("-R", "--reverse", dest="reverse", action="store_false", default=True,
                    help="reverse sort")
    parser.add_option("", "--before", dest="before", type="string", action="store", 
                    help="only output results seen before this time")
    parser.add_option("", "--after", dest="after", type="string", action="store", 
                    help="only output results seen after this time")
    return parser

if __name__ == "__main__":

    parser = parse_option()
    options, args = parser.parse_args()

    if options.version:
        print "flint %s" %__VERSION__
        sys.exit(0)

    if len(args) <2:
        parser.print_help()
        sys.exit(1)

    f_table = args[0]
    if f_table not in FLINT_TABLES:
       print "Table must be in %s" %("|".join(FLINT_TABLES))
       sys.exit(1)

    f_keyword = args[1]
    
    f_type = args[2] if len(args)>2 else None
    if f_type is not None:
       f_type = f_type.upper()
       if f_type not in FLINT_TYPES.keys():
           print "Type must be in %s" %("|".join(FLINT_TYPES))
           sys.exit(1)

    if options.sort not in FLINT_SORT_FIELD:
        print "Sort field must be in %s" %("|".join(FLINT_SORT_FIELD))
        sys.exit(1)
        
    flint = FlintClient(API, API_ID, API_KEY, options.verbose) 
    flint(f_table, f_keyword, f_type, **options.__dict__)

    
    

